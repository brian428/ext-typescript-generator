// Type definitions for DeftJS 0.9
// Project: http://www.sencha.com/products/deftjs/
// Definitions by: Brian Kotek <https://github.com/brian428/>
// Definitions: https://github.com/borisyankov/DefinitelyTyped

declare module Ext { export interface IBase {} }

declare module Deft.core {
	export interface IClass extends Ext.IBase {
	}
	export class Class {
		/** [Method] Determines whether the passed Class reference is or extends the specified Class by name 
		* @param targetClass Object 
		* @param className Object 
		*/
		static extendsClass( targetClass?:any, className?:any ): boolean;
		/** [Method] Intercept class creation  
		* @param hooks Object 
		* @param fn Object 
		*/
		static hookOnClassCreated( hooks?:any, fn?:any ): void;
		/** [Method] Intercept class extension  
		* @param data Object 
		* @param fn Object 
		*/
		static hookOnClassExtended( data?:any, fn?:any ): void;
		/** [Method] Register a new pre processor to be used during the class creation process  
		* @param name String The pre-processor's name. 
		* @param fn Function The callback function to be executed. 
		* @param position String Optional insertion position for this pre-processor - valid options: 'first', 'last', 'before' or 'after'. 
		* @param relativeTo String Optional name of a previously registered pre-processor, for 'before' and 'after' relative positioning. 
		*/
		static registerPreprocessor( name?:string, fn?:any, position?:string, relativeTo?:string ): void;
	}
}
declare module Deft {
	export interface IClass extends Ext.IBase {
	}
	export class Class {
		/** [Method] Determines whether the passed Class reference is or extends the specified Class by name 
		* @param targetClass Object 
		* @param className Object 
		*/
		static extendsClass( targetClass?:any, className?:any ): boolean;
		/** [Method] Intercept class creation  
		* @param hooks Object 
		* @param fn Object 
		*/
		static hookOnClassCreated( hooks?:any, fn?:any ): void;
		/** [Method] Intercept class extension  
		* @param data Object 
		* @param fn Object 
		*/
		static hookOnClassExtended( data?:any, fn?:any ): void;
		/** [Method] Register a new pre processor to be used during the class creation process  
		* @param name String The pre-processor's name. 
		* @param fn Function The callback function to be executed. 
		* @param position String Optional insertion position for this pre-processor - valid options: 'first', 'last', 'before' or 'after'. 
		* @param relativeTo String Optional name of a previously registered pre-processor, for 'before' and 'after' relative positioning. 
		*/
		static registerPreprocessor( name?:string, fn?:any, position?:string, relativeTo?:string ): void;
	}
}
declare module Deft.event {
	export interface ILiveEventBus extends Ext.IBase {
	}
	export class LiveEventBus {
	}
}
declare module Deft {
	export interface ILiveEventBus extends Ext.IBase {
	}
	export class LiveEventBus {
	}
}
declare module Deft.event {
	export interface ILiveEventListener extends Ext.IBase {
	}
}
declare module Deft {
	export interface ILiveEventListener extends Ext.IBase {
	}
}
declare module Deft.ioc {
	export interface IDependencyProvider extends Ext.IBase {
		/** [Config Option] (Object) */
		className?: any;
		/** [Config Option] (Boolean) */
		eager?: boolean;
		/** [Config Option] (Object) */
		fn?: any;
		/** [Config Option] (Object) */
		parameters?: any;
		/** [Config Option] (Boolean) */
		singleton?: boolean;
		/** [Config Option] (Object) */
		value?: any;
		/** [Method] Returns the value of className  */
		getClassName?(): any;
		/** [Method] Returns the value of eager  */
		getEager?(): boolean;
		/** [Method] Returns the value of fn  */
		getFn?(): any;
		/** [Method] Returns the value of identifier  */
		getIdentifier?(): any;
		/** [Method] Returns the value of parameters  */
		getParameters?(): any;
		/** [Method] Returns the value of singleton  */
		getSingleton?(): boolean;
		/** [Method] Returns the value of value  */
		getValue?(): any;
		/** [Method] Resolve a target instance s dependency with an object instance or value generated by this dependency provider  
		* @param targetInstance Object 
		* @param targetInstanceConstructorArguments Object 
		*/
		resolve?( targetInstance?:any, targetInstanceConstructorArguments?:any ): void;
		/** [Method] Sets the value of className  
		* @param className Object 
		*/
		setClassName?( className?:any ): void;
		/** [Method] Sets the value of eager  
		* @param eager Boolean 
		*/
		setEager?( eager?:boolean ): void;
		/** [Method] Sets the value of fn  
		* @param fn Object 
		*/
		setFn?( fn?:any ): void;
		/** [Method] Sets the value of identifier  
		* @param identifier Object 
		*/
		setIdentifier?( identifier?:any ): void;
		/** [Method] Sets the value of parameters  
		* @param parameters Object 
		*/
		setParameters?( parameters?:any ): void;
		/** [Method] Sets the value of singleton  
		* @param singleton Boolean 
		*/
		setSingleton?( singleton?:boolean ): void;
		/** [Method] Sets the value of value  
		* @param value Object 
		*/
		setValue?( value?:any ): void;
	}
}
declare module Deft.ioc {
	export interface IInjector extends Ext.IBase {
	}
	export class Injector {
		/** [Method] Indicates whether the Injector can resolve a dependency by the specified identifier with the corresponding object ins  
		* @param identifier Object 
		*/
		static canResolve( identifier?:any ): void;
		/** [Method] Configure the Injector  
		* @param configuration Object 
		*/
		static configure( configuration?:any ): void;
		/** [Method] Inject dependencies by their identifiers into the target object instance  
		* @param identifiers Object 
		* @param targetInstance Object 
		* @param targetInstanceConstructorArguments Object 
		* @param targetInstanceIsInitialized Object 
		*/
		static inject( identifiers?:any, targetInstance?:any, targetInstanceConstructorArguments?:any, targetInstanceIsInitialized?:any ): void;
		/** [Method] Reset the Injector  */
		static reset(): void;
		/** [Method] Resolve a dependency by identifier with the corresponding object instance or value  
		* @param identifier Object 
		* @param targetInstance Object 
		* @param targetInstanceConstructorArguments Object 
		*/
		static resolve( identifier?:any, targetInstance?:any, targetInstanceConstructorArguments?:any ): void;
	}
}
declare module Deft {
	export interface IInjector extends Ext.IBase {
	}
	export class Injector {
		/** [Method] Indicates whether the Injector can resolve a dependency by the specified identifier with the corresponding object ins  
		* @param identifier Object 
		*/
		static canResolve( identifier?:any ): void;
		/** [Method] Configure the Injector  
		* @param configuration Object 
		*/
		static configure( configuration?:any ): void;
		/** [Method] Inject dependencies by their identifiers into the target object instance  
		* @param identifiers Object 
		* @param targetInstance Object 
		* @param targetInstanceConstructorArguments Object 
		* @param targetInstanceIsInitialized Object 
		*/
		static inject( identifiers?:any, targetInstance?:any, targetInstanceConstructorArguments?:any, targetInstanceIsInitialized?:any ): void;
		/** [Method] Reset the Injector  */
		static reset(): void;
		/** [Method] Resolve a dependency by identifier with the corresponding object instance or value  
		* @param identifier Object 
		* @param targetInstance Object 
		* @param targetInstanceConstructorArguments Object 
		*/
		static resolve( identifier?:any, targetInstance?:any, targetInstanceConstructorArguments?:any ): void;
	}
}
declare module Deft.log {
	export interface ILogger extends Ext.IBase {
	}
	export class Logger {
		/** [Method] Logs a message with deprecate priority  
		* @param message String The message to log. 
		*/
		static deprecate( message?:string ): void;
		/** [Method] Logs a message with error priority  
		* @param message String The message to log. 
		*/
		static error( message?:string ): void;
		/** [Method] Logs a message with info priority  
		* @param message String The message to log. 
		*/
		static info( message?:string ): void;
		/** [Method] Logs a message with the specified priority  
		* @param message String The message to log. 
		* @param priority String The priority of the log message. Valid values are: verbose, info, deprecate, warn and error. 
		*/
		static log( message?:string, priority?:string ): void;
		/** [Method] Logs a message with verbose priority  
		* @param message String The message to log. 
		*/
		static verbose( message?:string ): void;
		/** [Method] Logs a message with warn priority  
		* @param message String The message to log. 
		*/
		static warn( message?:string ): void;
	}
}
declare module Deft {
	export interface ILogger extends Ext.IBase {
	}
	export class Logger {
		/** [Method] Logs a message with deprecate priority  
		* @param message String The message to log. 
		*/
		static deprecate( message?:string ): void;
		/** [Method] Logs a message with error priority  
		* @param message String The message to log. 
		*/
		static error( message?:string ): void;
		/** [Method] Logs a message with info priority  
		* @param message String The message to log. 
		*/
		static info( message?:string ): void;
		/** [Method] Logs a message with the specified priority  
		* @param message String The message to log. 
		* @param priority String The priority of the log message. Valid values are: verbose, info, deprecate, warn and error. 
		*/
		static log( message?:string, priority?:string ): void;
		/** [Method] Logs a message with verbose priority  
		* @param message String The message to log. 
		*/
		static verbose( message?:string ): void;
		/** [Method] Logs a message with warn priority  
		* @param message String The message to log. 
		*/
		static warn( message?:string ): void;
	}
}
declare module Deft.mixin {
	export interface IControllable extends Ext.IBase {
	}
}
declare module Deft.mixin {
	export interface IInjectable extends Ext.IBase {
	}
}
declare module Deft.mvc {
	export interface IApplication extends Ext.IBase {
		/** [Property] (Boolean) */
		initialized?: boolean;
		/** [Method] Initialize the Application */
		init?(): void;
	}
}
declare module Deft {
	export interface IApplication extends Ext.IBase {
		/** [Property] (Boolean) */
		initialized?: boolean;
		/** [Method] Initialize the Application */
		init?(): void;
	}
}
declare module Deft.mvc {
	export interface IComponentSelector extends Ext.IBase {
		/** [Method] Add an event listener to this component selector  
		* @param eventName Object 
		* @param fn Object 
		* @param scope Object 
		* @param options Object 
		*/
		addListener?( eventName?:any, fn?:any, scope?:any, options?:any ): void;
		/** [Method] Remove an event listener from this component selector  
		* @param eventName Object 
		* @param fn Object 
		* @param scope Object 
		*/
		removeListener?( eventName?:any, fn?:any, scope?:any ): void;
	}
}
declare module Deft.mvc {
	export interface IComponentSelectorListener extends Ext.IBase {
	}
}
declare module Deft.mvc {
	export interface IObserver extends Ext.IBase {
		/** [Method] Iterate through the listeners array and remove each event listener  */
		destroy?(): void;
		/** [Method] Retrieves the value for the specified object key and removes the pair from the object  
		* @param object Object 
		* @param key Object 
		*/
		extract?( object?:any, key?:any ): void;
		/** [Method] Returns true if the passed target is a string containing a indicating that it is referencing a nested property  
		* @param target Object 
		*/
		isPropertyChain?( target?:any ): void;
		/** [Method] Returns true if the passed host has a target that is Observable  
		* @param host Object 
		* @param target Object 
		*/
		isTargetObservable?( host?:any, target?:any ): void;
		/** [Method] Given a host object target property name and handler return object references for the final target and handler fun  
		* @param host Object 
		* @param target Object 
		* @param handler Object 
		*/
		locateReferences?( host?:any, target?:any, handler?:any ): void;
		/** [Method] Attempts to locate an observer target given the host object and target property name  
		* @param host Object 
		* @param target Object 
		*/
		locateTarget?( host?:any, target?:any ): void;
		/** [Method] Given a target property chain and a property host object recurse down the property chain and return the final host o  
		* @param host Object 
		* @param target Object 
		*/
		parsePropertyChain?( host?:any, target?:any ): void;
	}
	export class Observer {
		/** [Method] Merges child and parent observers into a single object  
		* @param originalParentObserve Object 
		* @param originalChildObserve Object 
		*/
		static mergeObserve( originalParentObserve?:any, originalChildObserve?:any ): void;
	}
}
declare module Deft.mvc {
	export interface IViewController extends Ext.IBase {
		/** [Config Option] (Object) */
		view?: any;
		/** [Property] (Object) */
		observe?: any;
		/** [Method] Add a component accessor method the ViewController for the specified view relative selector  
		* @param id Object 
		* @param selector Object 
		* @param live Object 
		*/
		addComponentReference?( id?:any, selector?:any, live?:any ): void;
		/** [Method] Add a component selector with the specified listeners for the specified view relative selector  
		* @param selector Object 
		* @param listeners Object 
		* @param live Object 
		*/
		addComponentSelector?( selector?:any, listeners?:any, live?:any ): void;
		/** [Method]  
		* @param view Object 
		*/
		controlView?( view?:any ): void;
		/** [Method]  */
		createObservers?(): void;
		/** [Method] Destroy the ViewController */
		destroy?(): void;
		/** [Method] Get the component selectorcorresponding to the specified view relative selector  
		* @param selector Object 
		*/
		getComponentSelector?( selector?:any ): void;
		/** [Method] Returns the value of view  */
		getView?(): any;
		/** [Method] Get the component s corresponding to the specified view relative selector  
		* @param selector Object 
		*/
		getViewComponent?( selector?:any ): void;
		/** [Method] Initialize the ViewController */
		init?(): void;
		/** [Method] Remove a component accessor method the ViewController for the specified view relative selector  
		* @param id Object 
		*/
		removeComponentReference?( id?:any ): void;
		/** [Method] Remove a component selector with the specified listeners for the specified view relative selector  
		* @param selector Object 
		*/
		removeComponentSelector?( selector?:any ): void;
		/** [Method]  */
		removeObservers?(): void;
		/** [Method] Sets the value of view  
		* @param view Object 
		*/
		setView?( view?:any ): void;
	}
}
declare module Deft {
	export interface IViewController extends Ext.IBase {
		/** [Config Option] (Object) */
		view?: any;
		/** [Property] (Object) */
		observe?: any;
		/** [Method] Add a component accessor method the ViewController for the specified view relative selector  
		* @param id Object 
		* @param selector Object 
		* @param live Object 
		*/
		addComponentReference?( id?:any, selector?:any, live?:any ): void;
		/** [Method] Add a component selector with the specified listeners for the specified view relative selector  
		* @param selector Object 
		* @param listeners Object 
		* @param live Object 
		*/
		addComponentSelector?( selector?:any, listeners?:any, live?:any ): void;
		/** [Method]  
		* @param view Object 
		*/
		controlView?( view?:any ): void;
		/** [Method]  */
		createObservers?(): void;
		/** [Method] Destroy the ViewController */
		destroy?(): void;
		/** [Method] Get the component selectorcorresponding to the specified view relative selector  
		* @param selector Object 
		*/
		getComponentSelector?( selector?:any ): void;
		/** [Method] Returns the value of view  */
		getView?(): any;
		/** [Method] Get the component s corresponding to the specified view relative selector  
		* @param selector Object 
		*/
		getViewComponent?( selector?:any ): void;
		/** [Method] Initialize the ViewController */
		init?(): void;
		/** [Method] Remove a component accessor method the ViewController for the specified view relative selector  
		* @param id Object 
		*/
		removeComponentReference?( id?:any ): void;
		/** [Method] Remove a component selector with the specified listeners for the specified view relative selector  
		* @param selector Object 
		*/
		removeComponentSelector?( selector?:any ): void;
		/** [Method]  */
		removeObservers?(): void;
		/** [Method] Sets the value of view  
		* @param view Object 
		*/
		setView?( view?:any ): void;
	}
}
declare module Deft.promise {
	export interface IChain extends Ext.IBase {
	}
	export class Chain {
		/** [Method] Execute an Array or Promise of an Array of functions in parallel  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static parallel( fns?:any, scope?:any ): any;
		static parallel( fns?:Function[], scope?:any ): Deft.promise.IPromise;
		static parallel( fns?:Deft.promise.IPromise, scope?:any ): Deft.promise.IPromise;
		/** [Method] Execute an Array or Promise of an Array of functions as a pipeline where each function s result is passed to the s  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param initialValue Object Initial value to be passed to the first function in the pipeline. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static pipeline( fns?:any, initialValue?:any, scope?:any ): any;
		static pipeline( fns?:Function[], initialValue?:any, scope?:any ): Deft.promise.IPromise;
		static pipeline( fns?:Deft.promise.IPromise, initialValue?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Execute an Array or Promise of an Array of functions sequentially  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static sequence( fns?:any, scope?:any ): any;
		static sequence( fns?:Function[], scope?:any ): Deft.promise.IPromise;
		static sequence( fns?:Deft.promise.IPromise, scope?:any ): Deft.promise.IPromise;
	}
}
declare module Deft {
	export interface IChain extends Ext.IBase {
	}
	export class Chain {
		/** [Method] Execute an Array or Promise of an Array of functions in parallel  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static parallel( fns?:any, scope?:any ): any;
		static parallel( fns?:Function[], scope?:any ): Deft.promise.IPromise;
		static parallel( fns?:Deft.promise.IPromise, scope?:any ): Deft.promise.IPromise;
		/** [Method] Execute an Array or Promise of an Array of functions as a pipeline where each function s result is passed to the s  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param initialValue Object Initial value to be passed to the first function in the pipeline. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static pipeline( fns?:any, initialValue?:any, scope?:any ): any;
		static pipeline( fns?:Function[], initialValue?:any, scope?:any ): Deft.promise.IPromise;
		static pipeline( fns?:Deft.promise.IPromise, initialValue?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Execute an Array or Promise of an Array of functions sequentially  
		* @param fns Function[]/Deft.promise.Promise The Array (or Promise of an Array) of functions to execute. 
		* @param scope Object Optional scope in which to execute the specified functions. 
		*/
		static sequence( fns?:any, scope?:any ): any;
		static sequence( fns?:Function[], scope?:any ): Deft.promise.IPromise;
		static sequence( fns?:Deft.promise.IPromise, scope?:any ): Deft.promise.IPromise;
	}
}
declare module Deft.promise {
	export interface IDeferred extends Ext.IBase {
		/** [Property] (Deft.promise.Promise) */
		promise?: Deft.promise.IPromise;
		/** [Method] Returns the Promise of a future value associated with this Deferred  */
		getPromise?(): Deft.promise.IPromise;
		/** [Method] Rejects this Deferred s Promise with the specified reason  
		* @param reason Error The rejection reason. 
		*/
		reject?( reason?:Error ): void;
		/** [Method] Resolves this Deferred s Promise with the specified value  
		* @param value Mixed The resolved future value. 
		*/
		resolve?( value?:any ): void;
		/** [Method] Updates progress for this Deferred s Promise if it is still pending  
		* @param progress Mixed The progress value. 
		*/
		update?( progress?:any ): void;
	}
	export class Deferred {
		/** [Method] Returns a new Deft promise Promise that rejects immediately with the specified reason  
		* @param reason Error The rejection reason. 
		*/
		static reject( reason?:Error ): Deft.promise.IPromise;
		/** [Method] Returns a new Deft promise Promise that resolves immediately with the specified value  
		* @param value Mixed The resolved future value. 
		*/
		static resolve( value?:any ): Deft.promise.IPromise;
	}
}
declare module Deft {
	export interface IDeferred extends Ext.IBase {
		/** [Property] (Deft.promise.Promise) */
		promise?: Deft.promise.IPromise;
		/** [Method] Returns the Promise of a future value associated with this Deferred  */
		getPromise?(): Deft.promise.IPromise;
		/** [Method] Rejects this Deferred s Promise with the specified reason  
		* @param reason Error The rejection reason. 
		*/
		reject?( reason?:Error ): void;
		/** [Method] Resolves this Deferred s Promise with the specified value  
		* @param value Mixed The resolved future value. 
		*/
		resolve?( value?:any ): void;
		/** [Method] Updates progress for this Deferred s Promise if it is still pending  
		* @param progress Mixed The progress value. 
		*/
		update?( progress?:any ): void;
	}
	export class Deferred {
		/** [Method] Returns a new Deft promise Promise that rejects immediately with the specified reason  
		* @param reason Error The rejection reason. 
		*/
		static reject( reason?:Error ): Deft.promise.IPromise;
		/** [Method] Returns a new Deft promise Promise that resolves immediately with the specified value  
		* @param value Mixed The resolved future value. 
		*/
		static resolve( value?:any ): Deft.promise.IPromise;
	}
}
declare module Deft.promise {
	export interface IPromise extends Ext.IBase {
		/** [Method] Attaches a callback to this Deft promise Promise that will be called when it resolves or rejects  
		* @param onCompleted Function Callback function to be called when resolved or rejected. 
		* @param scope Object Optional scope for the callback. 
		*/
		always?( onCompleted?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Cancels this Deft promise Promise if it is still pending triggering a rejection with a CancellationError that will  */
		cancel?(): void;
		/** [Method] Terminates a Deft promise Promise chain ensuring that unhandled rejections will be thrown as Errors  */
		done?(): void;
		/** [Method] Logs the resolution or rejection of this Promise using Deft logger Logger log  
		* @param identifier String An optional identifier to incorporate into the resulting log entry. 
		*/
		log?( identifier?:string ): Deft.promise.IPromise;
		/** [Method] Attaches a callback that will be called if this Promise is rejected  
		* @param onRejected Function Callback function to be called when rejected. 
		* @param scope Object Optional scope for the callback. 
		*/
		otherwise?( onRejected?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Attaches callbacks that will be notified when this Promise s future value becomes available  
		* @param onFulfilled Function Callback function to be called when resolved. 
		* @param onRejected Function Callback function to be called when rejected. 
		* @param onProgress Function Callback function to be called with progress updates. 
		* @param scope Object Optional scope for the callback(s). 
		*/
		then?( onFulfilled?:any, onRejected?:any, onProgress?:any, scope?:any ): Deft.promise.IPromise;
	}
	export class Promise {
		/** [Method] Returns a new Promise that will only resolve once all the specified promisesOrValues have resolved  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		*/
		static all( promisesOrValues?:any ): any;
		static all( promisesOrValues?:any[] ): Deft.promise.IPromise;
		static all( promisesOrValues?:Deft.promise.IPromise[] ): Deft.promise.IPromise;
		static all( promisesOrValues?:Deft.promise.IPromise ): Deft.promise.IPromise;
		/** [Method] Initiates a competitive race returning a new Promise that will resolve when any one of the specified promisesOrValue  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		*/
		static any( promisesOrValues?:any ): any;
		static any( promisesOrValues?:any[] ): Deft.promise.IPromise;
		static any( promisesOrValues?:Deft.promise.IPromise[] ): Deft.promise.IPromise;
		static any( promisesOrValues?:Deft.promise.IPromise ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that will automatically resolve with the specified Promise or value after the specified delay  
		* @param promiseOrValue Mixed A Promise or value. 
		* @param milliseconds Number A delay duration (in milliseconds). 
		*/
		static delay( promiseOrValue?:any, milliseconds?:number ): Deft.promise.IPromise;
		/** [Method] Determines whether the specified value is a Promise including third party untrusted Promises or then  ables  based  
		* @param value Mixed A potential Promise. 
		*/
		static isPromise( value?:any ): boolean;
		/** [Method] Traditional map function similar to Array prototype map that allows input to contain promises and or values  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param mapFn Function A Function to call to transform each resolved value in the Array. 
		*/
		static map( promisesOrValues?:any, mapFn?:any ): any;
		static map( promisesOrValues?:any[], mapFn?:any ): Promise;
		static map( promisesOrValues?:Deft.promise.IPromise[], mapFn?:any ): Promise;
		static map( promisesOrValues?:Deft.promise.IPromise, mapFn?:any ): Promise;
		/** [Method] Returns a new function that wraps the specified function and caches the results for previously processed inputs  
		* @param fn Function A Function to wrap. 
		* @param scope Object An optional scope in which to execute the wrapped function. 
		* @param hashFn Function An optional function used to compute a hash key for storing the result, based on the arguments to the original function. 
		*/
		static memoize( fn?:any, scope?:any, hashFn?:any ): any;
		/** [Method] Traditional reduce function similar to Array reduce that allows input to contain promises and or values  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param reduceFn Function A Function to call to transform each successive item in the Array into the final reduced value. 
		* @param initialValue Mixed An initial Promise or value. 
		*/
		static reduce( promisesOrValues?:any, reduceFn?:any, initialValue?:any ): any;
		static reduce( promisesOrValues?:any[], reduceFn?:any, initialValue?:any ): Promise;
		static reduce( promisesOrValues?:Deft.promise.IPromise[], reduceFn?:any, initialValue?:any ): Promise;
		static reduce( promisesOrValues?:Deft.promise.IPromise, reduceFn?:any, initialValue?:any ): Promise;
		/** [Method] Initiates a competitive race returning a new Promise that will resolve when howMany of the specified promisesOrValue  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param howMany Number The expected number of resolved values. 
		*/
		static some( promisesOrValues?:any, howMany?:any ): any;
		static some( promisesOrValues?:any[], howMany?:number ): Deft.promise.IPromise;
		static some( promisesOrValues?:Deft.promise.IPromise[], howMany?:number ): Deft.promise.IPromise;
		static some( promisesOrValues?:Deft.promise.IPromise, howMany?:number ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that will automatically reject after the specified timeout in milliseconds if the specified p  
		* @param promiseOrValue Mixed A Promise or value. 
		* @param milliseconds Number A timeout duration (in milliseconds). 
		*/
		static timeout( promiseOrValue?:any, milliseconds?:number ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that resolves immediately for the specified value or resolves or rejects when the specified  
		* @param promiseOrValue Mixed A Promise (or third-party Promise or then()-able) or value. 
		*/
		static when( promiseOrValue?:any ): Deft.promise.IPromise;
	}
}
declare module Deft {
	export interface IPromise extends Ext.IBase {
		/** [Method] Attaches a callback to this Deft promise Promise that will be called when it resolves or rejects  
		* @param onCompleted Function Callback function to be called when resolved or rejected. 
		* @param scope Object Optional scope for the callback. 
		*/
		always?( onCompleted?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Cancels this Deft promise Promise if it is still pending triggering a rejection with a CancellationError that will  */
		cancel?(): void;
		/** [Method] Terminates a Deft promise Promise chain ensuring that unhandled rejections will be thrown as Errors  */
		done?(): void;
		/** [Method] Logs the resolution or rejection of this Promise using Deft logger Logger log  
		* @param identifier String An optional identifier to incorporate into the resulting log entry. 
		*/
		log?( identifier?:string ): Deft.promise.IPromise;
		/** [Method] Attaches a callback that will be called if this Promise is rejected  
		* @param onRejected Function Callback function to be called when rejected. 
		* @param scope Object Optional scope for the callback. 
		*/
		otherwise?( onRejected?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Attaches callbacks that will be notified when this Promise s future value becomes available  
		* @param onFulfilled Function Callback function to be called when resolved. 
		* @param onRejected Function Callback function to be called when rejected. 
		* @param onProgress Function Callback function to be called with progress updates. 
		* @param scope Object Optional scope for the callback(s). 
		*/
		then?( onFulfilled?:any, onRejected?:any, onProgress?:any, scope?:any ): Deft.promise.IPromise;
	}
	export class Promise {
		/** [Method] Returns a new Promise that will only resolve once all the specified promisesOrValues have resolved  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		*/
		static all( promisesOrValues?:any ): any;
		static all( promisesOrValues?:any[] ): Deft.promise.IPromise;
		static all( promisesOrValues?:Deft.promise.IPromise[] ): Deft.promise.IPromise;
		static all( promisesOrValues?:Deft.promise.IPromise ): Deft.promise.IPromise;
		/** [Method] Initiates a competitive race returning a new Promise that will resolve when any one of the specified promisesOrValue  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		*/
		static any( promisesOrValues?:any ): any;
		static any( promisesOrValues?:any[] ): Deft.promise.IPromise;
		static any( promisesOrValues?:Deft.promise.IPromise[] ): Deft.promise.IPromise;
		static any( promisesOrValues?:Deft.promise.IPromise ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that will automatically resolve with the specified Promise or value after the specified delay  
		* @param promiseOrValue Mixed A Promise or value. 
		* @param milliseconds Number A delay duration (in milliseconds). 
		*/
		static delay( promiseOrValue?:any, milliseconds?:number ): Deft.promise.IPromise;
		/** [Method] Determines whether the specified value is a Promise including third party untrusted Promises or then  ables  based  
		* @param value Mixed A potential Promise. 
		*/
		static isPromise( value?:any ): boolean;
		/** [Method] Traditional map function similar to Array prototype map that allows input to contain promises and or values  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param mapFn Function A Function to call to transform each resolved value in the Array. 
		*/
		static map( promisesOrValues?:any, mapFn?:any ): any;
		static map( promisesOrValues?:any[], mapFn?:any ): Promise;
		static map( promisesOrValues?:Deft.promise.IPromise[], mapFn?:any ): Promise;
		static map( promisesOrValues?:Deft.promise.IPromise, mapFn?:any ): Promise;
		/** [Method] Returns a new function that wraps the specified function and caches the results for previously processed inputs  
		* @param fn Function A Function to wrap. 
		* @param scope Object An optional scope in which to execute the wrapped function. 
		* @param hashFn Function An optional function used to compute a hash key for storing the result, based on the arguments to the original function. 
		*/
		static memoize( fn?:any, scope?:any, hashFn?:any ): any;
		/** [Method] Traditional reduce function similar to Array reduce that allows input to contain promises and or values  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param reduceFn Function A Function to call to transform each successive item in the Array into the final reduced value. 
		* @param initialValue Mixed An initial Promise or value. 
		*/
		static reduce( promisesOrValues?:any, reduceFn?:any, initialValue?:any ): any;
		static reduce( promisesOrValues?:any[], reduceFn?:any, initialValue?:any ): Promise;
		static reduce( promisesOrValues?:Deft.promise.IPromise[], reduceFn?:any, initialValue?:any ): Promise;
		static reduce( promisesOrValues?:Deft.promise.IPromise, reduceFn?:any, initialValue?:any ): Promise;
		/** [Method] Initiates a competitive race returning a new Promise that will resolve when howMany of the specified promisesOrValue  
		* @param promisesOrValues Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise An Array of values or Promises, or a Promise of an Array of values or Promises. 
		* @param howMany Number The expected number of resolved values. 
		*/
		static some( promisesOrValues?:any, howMany?:any ): any;
		static some( promisesOrValues?:any[], howMany?:number ): Deft.promise.IPromise;
		static some( promisesOrValues?:Deft.promise.IPromise[], howMany?:number ): Deft.promise.IPromise;
		static some( promisesOrValues?:Deft.promise.IPromise, howMany?:number ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that will automatically reject after the specified timeout in milliseconds if the specified p  
		* @param promiseOrValue Mixed A Promise or value. 
		* @param milliseconds Number A timeout duration (in milliseconds). 
		*/
		static timeout( promiseOrValue?:any, milliseconds?:number ): Deft.promise.IPromise;
		/** [Method] Returns a new Promise that resolves immediately for the specified value or resolves or rejects when the specified  
		* @param promiseOrValue Mixed A Promise (or third-party Promise or then()-able) or value. 
		*/
		static when( promiseOrValue?:any ): Deft.promise.IPromise;
	}
}
declare module Deft.promise {
	export interface IResolver extends Ext.IBase {
		/** [Method] Rejects this Resolver with the specified reason triggering it to execute the onRejected callback and propagate the  
		* @param reason Error The rejection reason. 
		*/
		reject?( reason?:Error ): void;
		/** [Method] Resolves this Resolver with the specified value triggering it to execute the onResolved callback and propagate the  
		* @param value Mixed The resolved future value. 
		*/
		resolve?( value?:any ): void;
		/** [Method] Schedules creation of a new Resolver that originates from this Resolver configured with the specified callbacks  
		* @param onFulfilled Function Callback function to be called when resolved. 
		* @param onRejected Function Callback function to be called when rejected. 
		* @param onProgress Function Callback function to be called with progress updates. 
		* @param scope Object Optional scope for the callback(s). 
		*/
		then?( onFulfilled?:any, onRejected?:any, onProgress?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Updates progress for this Resolver if it is still pending triggering it to execute the onProgress callback and pr  
		* @param progress Mixed The progress value. 
		*/
		update?( progress?:any ): void;
	}
}
declare module Deft {
	export interface IResolver extends Ext.IBase {
		/** [Method] Rejects this Resolver with the specified reason triggering it to execute the onRejected callback and propagate the  
		* @param reason Error The rejection reason. 
		*/
		reject?( reason?:Error ): void;
		/** [Method] Resolves this Resolver with the specified value triggering it to execute the onResolved callback and propagate the  
		* @param value Mixed The resolved future value. 
		*/
		resolve?( value?:any ): void;
		/** [Method] Schedules creation of a new Resolver that originates from this Resolver configured with the specified callbacks  
		* @param onFulfilled Function Callback function to be called when resolved. 
		* @param onRejected Function Callback function to be called when rejected. 
		* @param onProgress Function Callback function to be called with progress updates. 
		* @param scope Object Optional scope for the callback(s). 
		*/
		then?( onFulfilled?:any, onRejected?:any, onProgress?:any, scope?:any ): Deft.promise.IPromise;
		/** [Method] Updates progress for this Resolver if it is still pending triggering it to execute the onProgress callback and pr  
		* @param progress Mixed The progress value. 
		*/
		update?( progress?:any ): void;
	}
}
declare module Deft.util {
	export interface IFunction extends Ext.IBase {
	}
	export class Function {
		/** [Method] Returns a new wrapper function that caches the return value for previously processed function argument s 
		* @param fn Function Function to wrap. 
		* @param scope Object Optional scope in which to execute the wrapped function. 
		* @param hashFn Function Optional function used to compute a hash key for storing the result, based on the arguments to the original function. 
		*/
		static memoize( fn?:any, scope?:any, hashFn?:any ): any;
		/** [Method] Schedules the specified callback function to be executed on the next turn of the event loop  
		* @param fn Function Callback function. 
		* @param scope Object Optional scope for the callback. 
		*/
		static nextTick( fn?:any, scope?:any ): void;
		/** [Method] Creates a new wrapper function that spreads the passed Array over the target function arguments  
		* @param fn Function Function to wrap. 
		* @param scope Object Optional scope in which to execute the wrapped function. 
		*/
		static spread( fn?:any, scope?:any ): any;
	}
}
declare module Deft {
	export interface IFunction extends Ext.IBase {
	}
	export class Function {
		/** [Method] Returns a new wrapper function that caches the return value for previously processed function argument s 
		* @param fn Function Function to wrap. 
		* @param scope Object Optional scope in which to execute the wrapped function. 
		* @param hashFn Function Optional function used to compute a hash key for storing the result, based on the arguments to the original function. 
		*/
		static memoize( fn?:any, scope?:any, hashFn?:any ): any;
		/** [Method] Schedules the specified callback function to be executed on the next turn of the event loop  
		* @param fn Function Callback function. 
		* @param scope Object Optional scope for the callback. 
		*/
		static nextTick( fn?:any, scope?:any ): void;
		/** [Method] Creates a new wrapper function that spreads the passed Array over the target function arguments  
		* @param fn Function Function to wrap. 
		* @param scope Object Optional scope in which to execute the wrapped function. 
		*/
		static spread( fn?:any, scope?:any ): any;
	}
}
