// Run at command line using 'gradle -q'

import groovy.json.*

defaultTasks 'build'

project.ext {
	libraryName = "ExtJS"
	libraryVersion = "4.2.0"

	// False to omit private methods/properties
	includePrivate = false

	// True to include full type values for properties, params, and return types.
	// Generates method overrides where necessary
	// WARNING: enabling types creates a definition with hundreds of compile errors due to incorrect docs or invalid scenarios in ExtJS itself
	// False to omit all types and set everything to "any"
	useFullTyping = true

	// Force all parameter types to "any" where possible
	forceAllParamsToOptional = true

	// False to generate separate definitions for each package
	singleDefinition = true
	currentModule = ""


	definitionPath = "./definition"
	definitionFile = new File( "${definitionPath}/${ libraryName }-${ libraryVersion }-${ useFullTyping ? 'Typed' : 'Untyped' }.d.ts" )

	// Handle one-off cases where ExtJS (or its JSDuck docs) create invalid scenarios...
	specialCases = [:]
	addSpecialCase( "Ext.grid.column.Action", "isDisabled", "delete" )
	addSpecialCase( "Ext.Component", "draggable", "delete" )
	addSpecialCase( "Ext.ComponentLoader", "renderer", "delete" )

	addSpecialCase( "Ext.AbstractComponent", "animate", "toProperty" )
	addSpecialCase( "Ext.util.Animate", "animate", "toProperty" )
	addSpecialCase( "Ext.form.field.Date", "safeParse", "toProperty" )

	addSpecialCase( "overrideReturnType", "Ext.form.field.Field", "any" )
	addSpecialCase( "overrideReturnType", "Ext.slider.Multi", "any" )
	addSpecialCase( "overrideReturnType", "Ext.slider.Single", "any" )

}

def addSpecialCase( key1, key2, value ) {
	if( !specialCases[ key1 ] ) specialCases[ key1 ] = [:]
	specialCases[ key1 ][ key2 ] = value
}

def getSpecialCase( key1, key2, value=null ) {
	if( specialCases[ key1 ] && specialCases[ key1 ][ key2 ] && !value ) {
		return specialCases[ key1 ][ key2 ]
	}
	else if( value && specialCases[ key1 ] && specialCases[ key1 ][ key2 ] == value ) {
		return true
	}
	else {
		return false
	}
}

// TASKS

/*
task wrapper( type: Wrapper ) {
	gradleVersion = '1.4'
}
*/


/*
Special cases:

In Ext.grid.column.(I)Action, omit isDisabled cfg item
In Ext.grid.(I)ActionColumn, omit isDisabled cfg item (alias for Ext.grid.column.Action)
In Ext.(I)AbstractComponent, turn animate() method into animate:any
In Ext.util.(I)Animate, turn animate() method into animate:any

In Ext.form.field.*, setValue() return any (or maybe Ext.form.field.(I)Base?)
In Ext.form.field.(I)Date, safeParse() return any

*/

task initialize() << {
	new File( definitionPath ).deleteDir()
	new File( definitionPath ).mkdir()

	println " "
	println "Creating ExtJS Definition File..."
	println " "

	def temp = getSpecialCase( "Ext.AbstractComponent", "animate" )
	def temp2 = getSpecialCase( "Ext.AbstractComponent", "animateXXX" )

	if( project.singleDefinition ) {
		project.definitionFile.write( "" )
		writeToDefinition( "// ${ libraryName } ${ libraryVersion } TypeScript Library Definition\n" )
	}
}

task readFiles( dependsOn: initialize ) << {

	def jsonDocPath = new File( "./jsondocs" )
	def jsonDocCollection = files { jsonDocPath.listFiles() }
	def jsonDocFiles = jsonDocCollection.getFiles()

	jsonDocFiles.each { file ->
		def slurper = new JsonSlurper()
    	def fileJson = slurper.parseText( file.text )

		// Only handle classes, not JS primitives like String
		if( fileJson.name.contains( "Ext" ) ) {
			def aliases = getAliases( fileJson )
			println( "Processing ${ fileJson.name }" )
			processModule( fileJson.name, fileJson )

			// Also generate definitions for alternate class names, since crazy ExtJS swaps them out all over the docs...
			fileJson.alternateClassNames.each { thisAlias ->

				// Some aliases are absurdly the same as the original, but with different package case, so skip these
				if( thisAlias.toLowerCase() != fileJson.name.toLowerCase() )
					processModule( thisAlias, fileJson )
			}
		}
	}
}

def processModule( className, fileJson ) {
	project.currentModule = getModule( className )
	writeToDefinition( "declare module ${ getModule( className ) } {" )
	def processedNames

	// Ext class has special handling to turn it into Ext module-level properties and methods.
	if( className == "Ext" ) {
		processedNames = writeProperties( fileJson, false, true )
		writeMethods( fileJson, processedNames, false, true )
	}
	else {
		processClass( className, fileJson )
	}

	writeToDefinition( "}" )
}

def processClass( className, fileJson ) {
	def processedNames
	writeToDefinition( "\texport interface I${ getClassName( className ) } ${ getExtends( fileJson, true ) } {" )
	if( !fileJson.singleton ) {
		processedNames = writeProperties( fileJson, true, false )
		writeMethods( fileJson, processedNames, true, false )
	}
	writeToDefinition( "\t}" )

	writeToDefinition( "\texport class ${ getClassName( className ) } ${ getExtends( fileJson, false ) } ${getImplementedInterfaces( fileJson ) } {" )
	processedNames = writeProperties( fileJson, false, false )
	writeMethods( fileJson, processedNames, false, false )
	writeToDefinition( "\t}" )
}

def getExtends( fileJson, isInterface ) {
	// fileJson.superclasses.last() for extends
	def result = ""
	if( fileJson.superclasses?.size() > 0 ) {
		if( isInterface ) {
			if( fileJson.superclasses.last().contains( "Ext." ) )
				result = "extends ${ normalizeType( convertToInterface( fileJson.superclasses.last() ), true ) }"
		}
		else {
			if( getClassName( fileJson.name ) != fileJson.superclasses.last() )
				result = "extends ${ normalizeType( fileJson.superclasses.last(), true ) }"
		}
	}
	return result
}

def getImplementedInterfaces( fileJson ) {
	def result = "implements ${ normalizeType( convertToInterface( fileJson.name ), true ) }"
	def implementedInterfaces = []

	fileJson.mixins?.each { thisMixin ->
		implementedInterfaces.add( normalizeType( convertToInterface( thisMixin ), true ) )
	}

	if( implementedInterfaces.size() > 0 ) {
		result += ",${ implementedInterfaces.join( ',' ) }"
	}

	return result
}

task build( dependsOn: readFiles ) << {
	println " "
	println "Build complete"
	println " "
}


// HELPER METHODS

def getModule( name ) {
	def tokenizedName = name.tokenize( "." )
	if( tokenizedName.size() == 1 ) return name

	tokenizedName.pop()

	// Some package names absurdly duplicate class names like Ext.data.Store, so lowercase them...
	tokenizedName.eachWithIndex { thisName, i ->
		if( thisName != "Ext" ) tokenizedName[ i ] = thisName.toLowerCase()
	}
	return tokenizedName.join( "." )
}

def getClassName( name ) {
	def tokenizedName = name.tokenize( "." )
	def className = tokenizedName.last()
	return className
}

def getAliases( fileJson ) {
	return fileJson.aliases.widget
}

def writeProperties( fileJson, isInterface, useExport ) {
	def classConfig = fileJson.members.cfg
	def classProperties = fileJson.members.property
	def optionalFlag = isInterface ? "?" : ""
	def thisType
	def processedConfigNames = [:]
	def exportString = useExport ? "export var " : ""

	classConfig.each { value ->
		if( value.owner == fileJson.name ) {
			if( !includePrivate && value.private != true ) {

				// Don't output special cases where an item should be omitted due to incompatible ExtJS API overrides in subclasses
				if( !getSpecialCase( fileJson.name, value.name, "delete" ) ) {
					thisType = value.type

					// Property type conversions
					if( thisType.contains( "/" ) || thisType.contains( "|" ) ) thisType = "any"

					writeToDefinition( "\t\t/** [Config Option] (${value.type}) ${ formatCommentText( value.shortDoc ) } */" )
					writeToDefinition( "\t\t${ exportString }${ value.name.replaceAll( '-', '' ) }${ optionalFlag }: ${ normalizeType( convertToInterface( thisType ) ) };" )
				}

				processedConfigNames[ value.name ] = true
			}
		}
	}

	classProperties.each { value ->
		if( value.owner == fileJson.name ) {
			if( !includePrivate && value.private != true ) {
				if( !processedConfigNames[ value.name ] ) {
					thisType = value.type
					if( thisType.contains( "/" ) || thisType.contains( "|" ) ) thisType = "any"

					writeToDefinition( "\t\t/** [Property] (${value.type}) ${ formatCommentText( value.shortDoc ) } */" )
					writeToDefinition( "\t\t${ exportString }${ value.name.replaceAll( '-', '' ) }${ optionalFlag }: ${ normalizeType( convertToInterface( thisType ) ) };" )
					processedConfigNames[ value.name ] = true
				}
			}
		}
	}
	return processedConfigNames
}

def writeMethods( fileJson, processedNames, isInterface, useExport ) {
	def classMethods = fileJson.members.method
	def optionalFlag = isInterface ? "?" : ""
	def shouldUseExport = useExport
	def isSingleton = fileJson.singleton && !isInterface

	classMethods.each { thisMethod ->

		if( thisMethod.owner == fileJson.name || ( fileJson.mixins && thisMethod.owner in fileJson.mixins ) ) {
			if( !includePrivate && thisMethod.private != true ) {
				if( !processedNames[ thisMethod.name ] && !thisMethod?.meta?.deprecated ) {

					// Don't output special cases where return type isn't valid
					if( getSpecialCase( "overrideReturnType", thisMethod.return.type ) ) {
						thisMethod.return.type = getSpecialCase( "overrideReturnType", thisMethod.return.type )
					}

					// Don't output special cases where an item should be omitted due to incompatible ExtJS API overrides in subclasses
					if( getSpecialCase( fileJson.name, thisMethod.name, "toProperty" ) ) {
						writeToDefinition( "\t\t/** [Method] ${ formatCommentText( thisMethod.shortDoc ) } */" )
						writeToDefinition( "\t\t${ thisMethod.name.replaceAll( '-', '' ) }${ optionalFlag }: any;" )
					}
					else {

						def tokenizedTypes = useFullTyping ? getTokenizedTypes( thisMethod.return.type ) : [ "any" ]

						tokenizedTypes.each { thisType ->

							// Return type conversions
							if( thisType == "undefined" ) thisType = "void"

							def paramNames = []
							def paramTypes = []
							def requiresOverrides = false

							thisMethod.params.each { thisParam ->
								paramNames.add( [ name:thisParam.name, optional:thisParam.optional, doc:thisParam.doc, default:thisParam.default ] )

								if( useFullTyping ) {
									def tokenizedParamTypes = getTokenizedTypes( thisParam.type )
									if( tokenizedParamTypes.size() > 1 && !requiresOverrides ) {
										requiresOverrides = true
									}
									paramTypes.add( tokenizedParamTypes )
								}
								else {
									paramTypes.add( thisParam.type )
								}
							}

							def usedPermutations = [:]

							if( !useFullTyping ) {
								writeMethod( thisMethod.shortDoc, thisMethod.name, optionalFlag, paramNames, paramTypes, thisType, shouldUseExport, isSingleton )
							}
							else if( useFullTyping && requiresOverrides && tokenizedTypes.first() == thisType ) {
								def overrideTypes = []
								paramNames.each { thisParamName ->
									overrideTypes.add( "any" )
								}
								writeMethod( thisMethod.shortDoc, thisMethod.name, optionalFlag, paramNames, overrideTypes, "any", shouldUseExport, isSingleton )
								usedPermutations[ overrideTypes.join( ',' ) ] = true
							}

							if( useFullTyping ) {
								def paramPermutations = GroovyCollections.combinations( paramTypes )

								paramPermutations.each { thisPermutation ->
									if( !requiresOverrides || ( requiresOverrides && thisPermutation.count{ normalizeType( it ) == "any" } < thisPermutation.size() ) ) {
										def thisPermutationAsString = thisPermutation.join( ',' )
										if( !usedPermutations[ thisPermutationAsString ] ) {
											writeMethod( thisMethod.shortDoc, thisMethod.name, optionalFlag, paramNames, thisPermutation, thisType, shouldUseExport, isSingleton )
											usedPermutations[ thisPermutationAsString ] = true
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

def getTokenizedTypes( types ) {
	def result = types.replaceAll( "\\|", "/").tokenize( "/" )
	if( result.size() > 1 && types.contains( "Object" ) )
		result = ["any"]
	return result.unique()
}

def writeMethod( comment, methodName, optionalFlag, paramNames, paramTypes, returnType, useExport, isStatic=false ) {

	def exportString = useExport ? "export function " : ""
	def staticString = ( isStatic && !useExport && methodName != "constructor" ) ? "static " : ""
	comment = "\t\t/** [Method] ${ comment?.replaceAll( "[\\W]", " " ) }"

	def paramsDoc = ""
	def methodOutput = "${ staticString }${ methodName }${ optionalFlag }("

	paramNames.eachWithIndex { thisParam, i ->
		def thisParamType = convertToInterface( paramTypes[ i ] )

		paramsDoc += "\t\t* @param ${ thisParam.name } ${ thisParamType } ${ formatCommentText( thisParam.doc ) }"
		if( thisParam.doc && thisParam.doc.contains( "Optional " ) ) thisParam.optional = true

		//func(...args: any[]): void;
		def spread = ""
		if( thisParamType.startsWith( "..." ) ) {
			spread = "..."
		}

		def thisParamName = thisParam.name

		// Param name conversions
		if( thisParamName == "class" ) thisParamName = "clazz"

		def optionalParamFlag = thisParam.optional ? "?" : ""
		if( spread.size() == 0 && forceAllParamsToOptional ) optionalParamFlag = "?"
		methodOutput += " ${spread}${ thisParamName }${ optionalParamFlag }:${ spread.length() > 0 ? "any[]" : normalizeType( thisParamType ) }"

		if( thisParam == paramNames.last() ) {
			methodOutput += " "
		}
		else {
			methodOutput += ","
			paramsDoc += "\n"
		}
	}

	if( paramsDoc.length() > 0 ) {
		writeToDefinition( comment )
		writeToDefinition( paramsDoc )
		writeToDefinition( "\t\t*/" )
	}
	else {
		writeToDefinition( "${ comment }*/" )
	}

	if( methodName != "constructor" ) {
		writeToDefinition( "\t\t${exportString}${ methodOutput }): ${ normalizeType( returnType ) };" )
	}
	else {
		writeToDefinition( "\t\t${ methodOutput });" )
	}
}

def normalizeType( typeName, forceFullType=false ) {
	if( !useFullTyping && !forceFullType )
		return "any"

	typeName = typeName.replaceAll( "\\.\\.\\.", "" )

	if( typeName.contains( "Ext." ) )
		typeName = "${ getModule( typeName )}.${ getClassName( typeName ) }"

	if( typeName == "Mixed" ) typeName = "any"
	if( typeName == "TextNode" ) typeName = "any"
	if( typeName == "Arguments" ) typeName = "any"
	if( typeName == "Object" ) typeName = "any"
	if( typeName == "String" ) typeName = "string"
	if( typeName == "Boolean" ) typeName = "bool"
	if( typeName == "Number" ) typeName = "number"

	return typeName
}

def convertToInterface( type ) {
	def result = type
	if( type.contains( "Ext." ) ) {
		result = "${ getModule( type ) }.I${ getClassName( type ) }"
	}
	return result
}

def formatCommentText( comment ) {
	def result = ""
	if( comment ) result += comment.replaceAll("<(.|\n)*?>", "").replaceAll( "[\\n\\t]", " " )
	return result
}

def writeToDefinition( value ) {
	if( singleDefinition ) {
		definitionFile.withWriterAppend( "UTF-8" ) { writer ->
			writer << value + "\n"
		}
	}
	else {
		def currentDefinitionFile = new File( "${ definitionPath }/${ currentModule }.d.ts" )
		if( !currentDefinitionFile.exists() ) currentDefinitionFile.createNewFile()

		currentDefinitionFile.withWriterAppend( "UTF-8" ) { writer ->
			writer << value + "\n"
		}
	}
}


// TODO: Remove when not needed for testing any longer...

def iterateSections( fileJson ) {
	println( "Sections:" )
	fileJson.members.each { key, value ->
		println( key )
		//iterateSectionElements( value )
	}
	println( " " )
}

def iterateSection( section ) {
	section.each { value ->
		iterateSectionElements( value )
	}
	println( " " )
}

def iterateSectionElements( section ) {
	println( section.name )
	section.each { key, value ->
		//println( key )
	}
	println( " " )
}
